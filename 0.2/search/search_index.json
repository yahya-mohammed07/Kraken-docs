{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Kraken","text":""},{"location":"#table-of-contents","title":"Table of Contents","text":"<ul> <li>Introduction</li> <li>Requirement</li> <li>Contents</li> <li>Installation</li> </ul>"},{"location":"#introduction","title":"Introduction","text":"<ul> <li><code>Kraken</code> is a modern math library written in a way that gives accurate results, compile time checks and simplicity.</li> </ul>"},{"location":"#requirement","title":"Requirement","text":"<ul> <li>c++20 or later</li> <li> <p>Tested on:</p> <ul> <li>g++10 std=c++2a</li> <li>g++11 std=c++2a</li> <li>clang++12 std=c++2a</li> <li>clang++11 std=c++2a</li> <li>clang++10 std=c++2a</li> </ul> </li> <li> <p>Catch2 for testing</p> </li> </ul>"},{"location":"#contents","title":"contents","text":"<ul> <li> <p>A matrix_&lt;&gt; class. For more info check: about_matrix</p> </li> <li> <p>namespace <code>kraken</code> which has:-</p> </li> <li> <p>namespace <code>constants</code>: contains mathematical and physical constants.</p> </li> <li>namespace <code>cal</code>: contains functions that do some calculations.</li> <li>namespace <code>op</code>: contains variadic function objects.</li> <li>and a bonus namespace! <code>num_methods</code> : contains implementation of some numerical methods.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<ul> <li>Download</li> <li>Adding the library to the intended path so the compiler can recognize it</li> <li>Any system</li> <li>Debian based systems</li> <li>Windows</li> </ul>"},{"location":"#download","title":"Download","text":"<ul> <li>A simple way is to download this library from <code>github</code> as <code>zip</code> then <code>unzip</code> it maybe using your os built-in unzip tool but the preferred way is to use PeaZip for windows and linux, for mac you can use keka.</li> </ul>"},{"location":"#all","title":"All","text":"<ul> <li> <p>If you downloaded it as <code>zip</code> and unzipped it, then in the unzipped library the root of the header folder hierarchy is <code>Kraken-master/source/library</code>.</p> </li> <li> <p>copy the <code>library</code> folder from the unzipped archive to your working directory as <code>Kraken</code> and include it this way.</p> </li> <li> <p>```cpp   #include \"Kraken/all.hpp\"   #include  <p>using namespace kraken;</p> <p>auto main()       -&gt; int   {     std::cout &lt;&lt; constants::pi &lt;&lt; '\\n';   }   ```</p>"},{"location":"#debian","title":"Debian","text":"<ul> <li> <p>If you downloaded it as <code>zip</code> and unzipped it, then in the unzipped library the root of the header folder hierarchy is <code>Kraken-master/source/library</code>.</p> </li> <li> <p>I.e. there is a <code>Kraken-master/source/library/all.hpp</code> header, which is the one that you want the compiler to find as . <li> <p>copy the <code>library</code> folder from the unzipped archive, to a folder that your compiler searches for headers.</p> </li> <p>And that folder is :-</p> <p>/usr/include</p>"},{"location":"#the-procedure-","title":"The procedure :-","text":"<ul> <li>Ui version</li> <li>if you're using <code>nautilus</code> file manager<ul> <li>open terminal then do <code>sudo apt install nautilus-admin</code> then when it's done do <code>nautilus -q</code>.</li> </ul> </li> <li> <p>if your're using <code>nemo</code> no need to install anything <code>run as-administer</code> is built-in.</p> </li> <li> <p>open <code>usr/include</code> folder as <code>administrator</code>.</p> </li> <li> <p>paste <code>library</code> folder into <code>usr/include</code>, then rename <code>library</code> into <code>Kraken</code>. you're done!.</p> </li> <li> <p>Terminal version</p> </li> <li>if you have any file manger installed you can open a folder as administer as follows:     <code>sudo</code> (your-file-manager) <code>/usr/include</code></li> <li>paste <code>library</code> folder into <code>usr/include</code>, then rename <code>library</code> into <code>Kraken</code>. you're done!.</li> </ul>"},{"location":"#windows","title":"windows","text":"<ul> <li> <p>If you downloaded it as <code>zip</code> and unzipped it, then in the unzipped library the root of the header folder hierarchy is <code>Kraken-master/source/library</code>.</p> </li> <li> <p>I.e. there is a <code>Kraken-master/source/library/all.hpp</code> header, which is the one that you want the compiler to find as . <li> <p>copy the <code>library</code> folder from the unzipped archive, to a folder that your compiler searches for headers.</p> </li> <li> <p>for the MinGW g++ compiler you might have a folder such as</p> <p>C:\\installed\\mingw\\nuwen\\MinGW (version)\\include</p> </li> <li> <p>just paste the <code>library</code> folder inside, then rename <code>library</code> into <code>Kraken</code>. you're done!</p> </li> <li> <p>for the Visual C++ compiler you might have a folder such as</p> <p>C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\ (version) \\include</p> </li> <li>just paste the <code>library</code> folder inside, then rename <code>library</code> into <code>Kraken</code>. you're done!</li>"},{"location":"#check-if-the-library-is-working-by-running-this-code-","title":"Check if the library is working by running this code:-","text":"<ul> <li>```cpp   #include    #include  <p>using namespace kraken;</p> <p>auto main()       -&gt; int   {     std::cout &lt;&lt; constants::omega  &lt;&lt; '\\n';   }   ```</p>"},{"location":"about_constants/","title":"This file contains helpful notes about <code>constants.hpp</code> file","text":""},{"location":"about_constants/#-whats-inside","title":"- What's inside?`","text":"<ul> <li>Math and physics constants as letters</li> </ul>"},{"location":"about_constants/#-usage-","title":"- Usage:-","text":"<pre><code>  std::cout &lt;&lt; \"\u03a9= \" &lt;&lt; constants::omega &lt;&lt; '\\n';\n  std::cout &lt;&lt; \"e= \" &lt;&lt; constants::e &lt;&lt; '\\n';\n  std::cout &lt;&lt; \"\u03c8= \" &lt;&lt; constants::sai &lt;&lt; '\\n';\n  std::cout &lt;&lt; \"\u03c0= \" &lt;&lt; constants::pi &lt;&lt; '\\n';\n  std::cout &lt;&lt; \"\u03c0= \" &lt;&lt; constants::pi_v&lt;float&gt; &lt;&lt; '\\n';\n  std::cout &lt;&lt; \"\u03c0= \" &lt;&lt; constants::pi_v&lt;long double&gt; &lt;&lt; '\\n';\n</code></pre>"},{"location":"about_matrix/","title":"This file contains helpful notes about <code>matrix.hpp</code> file","text":""},{"location":"about_matrix/#questions-you-might-ask-","title":"Questions you might ask:-","text":""},{"location":"about_matrix/#-is-it-built-from-scratch","title":"- Is it built from scratch?","text":"<ul> <li>No, it's built upon existing data-structure called <code>std::array</code></li> </ul>"},{"location":"about_matrix/#-reasons-for-creating-matrix_-class","title":"- Reasons for creating matrix_&lt;&gt; class?","text":"<ul> <li>The elements are stored in a 1D array</li> <li>It supports basic matrix and scalar operations (+,-,*)</li> <li>It supports Comparing operations (==, !=)</li> <li>Performance:-</li> <li>Uses templates to construct size, so it's static! which makes it <code>fast</code> but not resizable</li> <li>Compile time checks:-</li> <li>Must <code>row_size &gt; 0</code> And <code>column_size &gt; 0</code></li> </ul>"},{"location":"about_matrix/#usage-","title":"Usage:-","text":""},{"location":"about_matrix/#-creating-a-variable-of-type-matrix_-","title":"- Creating a variable of type matrix_&lt;&gt;:-","text":"<ul> <li><code>matrix_&lt;Type, row_size, column_size&gt; var_name</code></li> </ul>"},{"location":"about_matrix/#-initializing-a-matrix-variable-and-adding-data-","title":"- Initializing a matrix variable and adding data:-","text":""},{"location":"about_matrix/#-using-a-constructor","title":"- - Using a constructor","text":"<ul> <li><code>var_name { a1, a2, a3, a3 ... }</code></li> <li><code>var_name ( a1, a2, a3, a3 ... )</code> Recommended</li> <li><code>note</code>: number of elements must be less than <code>(row_size * column_size)</code></li> </ul>"},{"location":"about_matrix/#-using-fill-method","title":"- - Using fill method","text":"<ul> <li><code>fill</code> method fills the matrix with a certain value</li> </ul>"},{"location":"about_matrix/#-methods-built-int-with-matrix_-class","title":"- Methods built int with <code>matrix_&lt;&gt;</code> class","text":"<ul> <li><code>at()</code> :- get elements in that particular position</li> <li>Has four overloads :-<ul> <li>1- <code>at(row, col)</code> const (read-only)</li> <li>2- <code>at(row, col)</code> -&gt; auto&amp;</li> <li>3- <code>at&lt;row, col&gt;()</code> const (read-only)</li> <li>comes with compile time check</li> <li>4- <code>at&lt;row, col&gt;()</code> -&gt; auto&amp;</li> <li>comes with compile time check</li> </ul> </li> <li><code>size()</code> :- get the total size of the matrix (<code>row_size * column_size</code>)</li> <li><code>print()</code> :- prints the contests in matrix style</li> <li> <p>if the type was float, it will print using precession of <code>12</code></p> </li> <li> <p><code>fill()</code> :- fills the matrix with a certain value</p> </li> <li><code>transpose_squared()</code> :- changes its rows into columns and its columns into rows (only <code>squared</code> matrices )</li> <li><code>transpose_triangular()</code> :- changes its rows into columns and its columns into rows (only <code>triangular</code> matrices )</li> <li><code>sort()</code> :- sort elements in certain order</li> <li><code>if</code> <code>size &lt; 256</code> it will use (<code>insertion algorithm</code>)</li> <li><code>else</code> it will use (<code>std::sort</code>)</li> <li><code>swap_rows()</code> :- swaps rows based of user's choice</li> <li><code>swap_cols()</code> :- swaps columns based on user's choice</li> <li><code>empty()</code> :- returns <code>false</code> if not empty else returns <code>true</code></li> <li><code>rotate_squared&lt;true&gt;()</code> :- rotates transposed matrix into 90 degree (only for squared matrices)</li> <li><code>rotate_squared&lt;false&gt;()</code> :- rotates transposed matrix into -90 degree (only for squared matrices)</li> <li><code>rotate_triangular&lt;tROW,tCOL,true&gt;</code> :- rotates transposed matrix into 90 degree (only for triangular matrices)</li> <li><code>tROW,tCOL</code> :- are the new (row, col) after transposing</li> <li><code>rotate_triangular&lt;tROW,tCOL,true&gt;</code> :- rotates transposed matrix into -90 degree (only for triangular matrices)</li> <li><code>tROW,tCOL</code> :- are the new (row, col) after transposing</li> </ul>"},{"location":"about_numeric/","title":"This file contains helpful notes about <code>numeric.hpp</code> file","text":""},{"location":"about_numeric/#questions-you-might-ask-","title":"Questions you might ask :-","text":""},{"location":"about_numeric/#-most-of-the-functions-are-already-exist-in-cmath-what-is-the-difference","title":"- Most of the functions are already exist in <code>&lt;cmath&gt;</code> what is the difference?","text":"<ul> <li>In <code>numeric.hpp</code> most of these functions are built in <code>cpp20</code> standard and the special guests are <code>constexpr</code> and <code>type_traits</code> so, some of these functions are actually faster and more accurate! + you get compile time error checks!</li> </ul>"},{"location":"about_numeric/#-all-the-functions-are-built-with-constexpr","title":"- All the functions are built with <code>constexpr</code>?","text":"<ul> <li>mostly, Yes!</li> </ul>"},{"location":"about_numeric/#whats-inside","title":"What's inside?","text":"<ul> <li>1- implementation of <code>newton's method</code></li> <li>2- basic <code>iota</code> class given by Alf P. Steinbach</li> <li>3- <code>kraken::cal</code> namespace <code>cal</code> contains functions that do some calculations</li> <li>inside <code>kraken::cal</code>:</li> <li><code>acc</code>Is short for <code>accumulate</code>: It can compute <code>scalar operations (+,-,*)</code> of a container with no need of iterators</li> <li><code>calcu</code> Is short for <code>calculate</code>: It can compute <code>scalar operations (+,-,*)</code> on a <code>init-list</code> or <code>variadic</code> argument ( not recommended for <code>subtraction</code> )</li> <li><code>abs</code> uses bit masking for integrals</li> <li><code>floor</code></li> <li><code>ceil</code></li> <li><code>ln</code> : log base <code>e</code> of x</li> <li><code>log2</code>: for <code>int</code> values it uses super-fast <code>63 or 31 - std::countl-zero(x)</code>, for floating-point it uses: ln(x) * log2(e)</li> <li><code>log10</code>: for <code>int</code> values it uses super-fast <code>63 or 31 - std::countl-zero(x)</code>, for floating-point it uses: log2(x) / log2(10)</li> <li><code>pow</code></li> <li><code>pow_container</code></li> <li><code>hypot</code></li> <li><code>round</code></li> <li><code>sqr</code></li> <li><code>sqrt</code>: works using <code>newton's method</code></li> <li><code>max_range</code> : finds maximum value in a range</li> <li><code>min_range</code> : finds minium value in a range</li> <li><code>max</code></li> <li><code>min</code></li> <li><code>min_max</code>: gives a pair of <code>min</code> and <code>max</code></li> <li><code>gcd</code></li> <li><code>lcm</code></li> <li><code>trunc</code>: chops of the fractional part of any floating-point number</li> <li><code>decimal_places</code>: counts the number of elements after the decimal point</li> <li><code>fibonacci</code></li> <li><code>div</code> gives a pair of <code>quotient</code> and <code>remainder</code></li> <li><code>factorial</code> recursive</li> <li><code>is_neg</code> uses <code>Bit Twiddling</code> for integral types</li> <li><code>is_prime</code></li> <li><code>cos</code></li> <li><code>sin</code></li> <li><code>tan</code></li> <li><code>sec</code></li> <li><code>cosc</code></li> <li><code>cot</code></li> <li><code>arc_sin</code> Handbook of Mathematical Functions, M. Abramowitz and I.A. Stegun, Ed.</li> <li><code>arc_cos</code> range [0,pi], expecting x to be in the range [-1,+1].</li> <li><code>arc_tan</code></li> <li><code>frac</code></li> <li><code>fmod</code></li> <li><code>to_radian</code></li> <li><code>to_degree</code></li> <li><code>modf</code> returns a pair of the integral and the fractional part of a floating-point value</li> <li><code>ones_complement</code> computes 1's complement</li> <li><code>twos_complement</code> computes 2's complement</li> <li><code>exp</code> e^n</li> <li><code>gamma</code></li> <li><code>beta</code></li> <li><code>sign</code> gives sign bit of a floating point</li> <li><code>median</code></li> </ul>"},{"location":"about_numeric/#note-for-usage-please-check-the-tests-folder","title":"Note: for usage please check the <code>tests</code> folder","text":""},{"location":"about_numeric_methods/","title":"This file contains helpful notes about <code>numerical_methods.hpp</code> file","text":""},{"location":"about_numeric_methods/#-whats-inside","title":"- What's inside?","text":"<ul> <li>Pre implemented numeric-methods (some of them only work with <code>matrix_&lt;&gt;</code>)</li> <li>what numeric methods?<ul> <li>gauss_elimination</li> <li>determined</li> <li>least_squares</li> <li>cramer</li> <li>simpson</li> <li>newton</li> <li>back_substitution</li> <li>Newton's Forward Difference Formula</li> <li>Lagrange Interpolation</li> <li>and a helper function called <code>change_with_R</code></li> </ul> </li> </ul>"},{"location":"about_numeric_methods/#note-check-the-tests-folder-to-look-at-the-usage","title":"Note :- check the <code>tests</code> folder to look at the usage","text":""}]}